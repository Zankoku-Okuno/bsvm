; Parse a sqlstring from standard input.
; That is, stdin should have a single-quote delimited string, where the only
; escape sequence is two single quotes encoding a single quote.

.entrypoint &main

.def NEWLINE 0Ah
.def SINGLE_TICK 27h

.func main
  .reg c, die, stdin, stdout, buf, char
  .reg t1
  lia die, @die
  strm stdin, 0
  strm stdout, 1
  ;;; buf = FLookahead.new(stdin)
  jal &FLookahead.new, stdin
  into buf
  ;;; machine std() {
    ;;; std() {
    @machine.std:
      ;;; char = FLookahead.pop(buf, done, die)
      lia t1, @machine.done
      jal &FLookahead.pop, buf, t1, die
      into char
      ;;; if char == '\'' { goto quote() }
      eq c, char, $SINGLE_TICK
      cjmp c, @machine.quote
      ;;; if char == '\n' { goto std() }
      eq c, char, $NEWLINE
      cjmp c, @machine.std
      ;;; putc(stdout, char)
      putb stdout, char
    ;;; }
    jmp @machine.std
    ;;; quote() {
    @machine.quote:
      ;;; char = FLookahead.pop(buf, die, die)
      jal &FLookahead.pop, buf, die, die
      into char
      ;;; when char == '\'' {
      eq c, char, $SINGLE_TICK
      zjmp c, @machine.quote.no-tick
        ;;; if peek(buf, done, die) != '\'' { goto std() }
        lia t1, @machine.done
        jal &FLookahead.peek, buf, t1, die
        into t1
        eq c, t1, $SINGLE_TICK
        zjmp c, @machine.std
        ;;; pop(buf, die, die)
        jal &FLookahead.pop, buf, die, die
      ;;; }
      @machine.quote.no-tick:
      ;;; putc(stdout, char)
      putb stdout, char
    ;;; }
    jmp @machine.quote
  ;;; }
  @machine.done:
  ;;; FLookahead.del(buf); exit(0)
  jal &FLookahead.del, buf
  mov %0, 0
  exit %0
@die:
  ;;; exit(-1)
  mov %0, -1
  exit %0