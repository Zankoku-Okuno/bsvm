; Library for manipulating dynamically-sized buffers of bytes.
;
; export struct ByteBuf
; export $ByteBuf.{lenstr,len,buf}
; export ByteBuf.{new,del}
; export ByteBuf.resize
; export ByteBuf.append


;;; struct ByteBuf {
  ;;; uint cap
  .def ByteBuf.cap 0
  ;;; struct lenstr {
  .def ByteBuf.lenstr 1
    ;;; uint len
    .def ByteBuf.len 1
    ;;; *byte buf
    .def ByteBuf.buf 2
  ;;; }
;;; }
.def ByteBuf.size 3

; Create a new bytebuffer.
;
; uint cap0: initial capacity
; return(?*ByteBuf: pointer to new buffer)
.func ByteBuf.new cap0
  .reg out, buf
  .reg t1
  ;;; malloc(sizeof(ByteBuf))
  mov t1, 0
  off t1, $ByteBuf.size
  new out, t1
  zjmp out, @no-out
  ;;; out.{cap,len} = cap0, 0
  st out, $ByteBuf.cap, cap0
  mov t1, 0
  st out, $ByteBuf.len, t1
  ;;; out.buf = malloc(cap0)
  new buf, cap0
  zjmp buf, @no-buffer
  st out, $ByteBuf.buf, buf
  ;;; return out
  ret out
@no-buffer:
  ;;; free(out); out = NULL
  free out
  mov out, 0
@no-out:
  ;;; return out // which is always NULL here
  ret out

; Deallocate all data structures owned by this ByteBuf
;
; *ByteBuf self
; return()
.func ByteBuf.del self
  .reg buf
  ;;; free(self->buf), free(self)
  ld buf, self, $ByteBuf.buf
  free buf
  free self
  ;;; return
  ret

; Grow capacity or shrink length.
;
; &ByteBuf self
; uint size
; return()
; exit nomem()
.func ByteBuf.resize self, size, nomem
  .reg c
  .reg t1
  ;;; if size < self->len
  ld t1, self, $ByteBuf.len
  lt c, size, t1
  zjmp c, @larger
    ;;; self->len = size
    st self, $ByteBuf.len, size
    ret
  @larger:
  ;;; elif (self->cap < size)
  ld t1, self, $ByteBuf.cap
  lt c, t1, size
  zjmp c, @end-cond
    ;;; new = realloc(self->buf, size)
    ld t1, self, $ByteBuf.buf
    rnew t1, size
    ;;; when !new
    cjmp t1, @ok
      ;;; exit nomem()
      mov %0, nomem
      ret
    @ok:
    ;;; self->buf = new
    st self, $ByteBuf.buf, t1
  ;;; else {}
@end-cond:
  ;;; return
  ret

; Add a single byte to the end of the buffer
;
; &ByteBuf self
; byte byte
; return()
; exit nomem()
.func ByteBuf.append self, byte, nomem
  .reg c, cap, len, buf
  ;;; cap, len, buf = self->{cap,len,buf}
  ld cap, self, $ByteBuf.cap
  ld len, self, $ByteBuf.len
  ld buf, self, $ByteBuf.buf
  ;;; when (len == cap)
  eq c, len, cap
  zjmp c, @go
    ;;; buf = realloc(buf, 2*cap)
    add cap, cap
    rnew buf, cap
    ;;; when !buf
    cjmp buf, @ok
      ;;; exit nomem()
      mov %0, nomem
      ret
    @ok:
    ;;; self->{cap,buf} = cap, buf
    st self, $ByteBuf.cap, cap
    st self, $ByteBuf.buf, buf
  @go:
  ;;; self->buf[len] = byte
  add buf, len
  stb buf, byte
  ;;; self->len = len + 1
  add len, 1
  st self, $ByteBuf.len, len
  ;;; return
  ret
