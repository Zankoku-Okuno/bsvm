; Library for manipulating dynamically-sized buffers of bytes.
;
; export struct ByteBuf
; export $ByteBuf.{lenstr,len,str}
; export ByteBuf.{new,del}
; export ByteBuf.resize
; export ByteBuf.append


;;; struct ByteBuf {
  ;;; cap: uint
  .def ByteBuf.cap 0
  ;;; unpack lenstr<*>
  .def ByteBuf.lenstr 1
    .def ByteBuf.len $ByteBuf.lenstr + $lenstr.len
    .def ByteBuf.str $ByteBuf.lenstr + $lenstr.str
;;; }
.def ByteBuf.sizeof 1 + $lenstr.sizeof

; Create a new bytebuffer.
;
; uint cap0: initial capacity
; return(?*ByteBuf: pointer to new buffer)
.func ByteBuf.new cap0
  .reg out, str
  .reg t1
  ;;; malloc(sizeof(ByteBuf))
  mov t1, 0
  off t1, $ByteBuf.sizeof
  new out, t1
  zjmp out, @no-out
  ;;; out.{cap,len} = cap0, 0
  st out, $ByteBuf.cap, cap0
  mov t1, 0
  st out, $ByteBuf.len, t1
  ;;; out->str = malloc(cap0)
  new str, cap0
  zjmp str, @no-buffer
  st out, $ByteBuf.str, str
  ;;; return out
  ret out
@no-buffer:
  ;;; free(out); out = NULL
  free out
  mov out, 0
@no-out:
  ;;; return out // which is always NULL here
  ret out

; Deallocate all data structures owned by this ByteBuf
;
; *ByteBuf self
; return()
.func ByteBuf.del self
  .reg str
  ;;; free(self->str), free(self)
  ld str, self, $ByteBuf.str
  free str
  free self
  ;;; return
  ret

; Grow capacity or shrink length.
;
; &ByteBuf self
; uint size
; return()
; exit nomem()
.func ByteBuf.resize self, size, nomem
  .reg c
  .reg t1
  ;;; if size < self->len
  ld t1, self, $ByteBuf.len
  bl c, size, t1
  zjmp c, @larger
    ;;; self->len = size
    st self, $ByteBuf.len, size
    ret
  @larger:
  ;;; elif (self->cap < size)
  ld t1, self, $ByteBuf.cap
  bl c, t1, size
  zjmp c, @end-cond
    ;;; new = realloc(self->str, size)
    ld t1, self, $ByteBuf.str
    rnew t1, size
    ;;; when !new
    cjmp t1, @ok
      ;;; exit nomem()
      mov %0, nomem
      ret
    @ok:
    ;;; self->{size,str} = size, new
    st self, $ByteBuf.sizeof, size
    st self, $ByteBuf.str, t1
  ;;; else {}
@end-cond:
  ;;; return
  ret

; Add a single byte to the end of the buffer
;
; &ByteBuf self
; byte byte
; return()
; exit nomem()
.func ByteBuf.append self, byte, nomem
  .reg c, cap, len, str
  ;;; cap, len, str = self->{cap,len,str}
  ld cap, self, $ByteBuf.cap
  ld len, self, $ByteBuf.len
  ld str, self, $ByteBuf.str
  ;;; when (len == cap)
  eq c, len, cap
  zjmp c, @go
    ;;; cap *= 2
    add cap, cap
    ;;; str = realloc(str, cap)
    rnew str, cap
    ;;; when !str
    cjmp str, @ok
      ;;; exit nomem()
      mov %0, nomem
      ret
    @ok:
    ;;; self->{cap,str} = cap, str
    st self, $ByteBuf.cap, cap
    st self, $ByteBuf.str, str
  @go:
  ;;; self->str[len] = byte
  add str, len
  stb str, byte
  ;;; self->len = len + 1
  add len, 1
  st self, $ByteBuf.len, len
  ;;; return
  ret
